#' Massive Post and Delete Label/Annotation in a volume
#'
#' Functions about posting/deleting massive amounts of label/annotation records in the volume.
#'
#' @section
#' Functions:
#' * `postLabs_re` Reconstruct the volume's label from a label report (must be 'csv' type).
#' * `postAnnos_re` Reconstruct the volume's annotation from a annotation report (must be 'csv' type).
#' * `delAllLabs` Delete all labels on images in filename order.
#' * `delAllAnnos` Delete all annotations on images in filename order.
#' @docType package
#' @name volPostNDelete
NULL


# NOT EXPORT--------------------------------------------------------------------
# post one label
postALab <- function(url, auth, imageID, labelID){
  res <- POST(url = paste0(url, "/api/v1/images/", imageID,"/labels")
              , add_headers(Accept = "application/json"
                            ,Authorization = auth)
              , body = list(label_id = labelID))
  if(res$status_code != 201){
    return(data.table(imageFailed = imageID,
                      labelFailed = labelID))
  }else{
    return(NULL)
  }
}

# post one annotation
postAAnno <- function(url, auth, imageID, shapeID, labelID, point){
  res <- POST(url = paste0(url, "/api/v1/images/", imageID,"/annotations")
              , add_headers(Accept = "application/json"
                            ,Authorization = auth)
              , body = list(shape_id = as.character(shapeID)
                            , label_id =  as.character(labelID)
                            , confidence = "1"
                            , points = fromJSON(point))
              , encode = "json") # can only attach 1 label at a time
  if(res$status_code != 201){
    return(data.table(imageFailed = imageID,
                      labelFailed = labelID,
                      pointFailed = point,
                      shapeFailed = shapeID))
  }else{
    return(NULL)
  }
}

# delete one label added by you
delALab <-function(url, auth, imgLabID){
  res <- DELETE(url = paste0(url, "/api/v1/image-labels/", imgLabID)
                , add_headers(Accept = "application/json"
                              ,Authorization = auth))
  return(res$status_code == 200)
}

# delete one annotation
delAAnno <-function(url, auth, annoID){
  res <- DELETE(url = paste0(url, "/api/v1/image-annotations/", annoID)
                , add_headers(Accept = "application/json"
                              ,Authorization = auth))
  return(res$status_code == 200)
}


# EXPORT------------------------------------------------------------------------
#' Post labels for volume (reconstruct the volume)
#'
#' Reconstruct the volume's label from a label report (must be 'csv' type).\cr
#' For example, there are 2 volume contain the same image files. "Volume A" have some label records and "Volume B" is empty. You can use this function and input the label report of "Volume A" to post the same label record on "Volume B".\cr
#' Note that: This function post labels based on the filename. So, the 2 volume must have the same image filename.
#'
#' @param url BIIGLE server URL (e.g. "https://seaimage.oc.ntu.edu.tw").
#' @param auth Authentication string generated by \code{\link{genAuth}}.
#' @param volName The empty volume going to post (reconstruct) labels.
#' @param treeIDs Label trees  that need to use in this volume (vector with integer).
#' @param labReport The label report table (csv type). It can get by \code{\link{reqNgetRep}}.
#' @param checkFilename (OPTIONAL) Check whether the filename of input label report all exist in volume's image (imgList). Default: TRUE.
#' @examples
#' \dontrun{
#' postLabs_re(url = "https://seaimage.oc.ntu.edu.tw",
#'             auth = myAuth,
#'             volName = "odbiigle",
#'             treeIDs = 5,
#'             labReport = testReport,
#'             checkFilename = TRUE)
#' }
#' @export
postLabs_re <- function(url, auth, volName, treeIDs, labReport, checkFilename = TRUE){
  imgList <- getVolImg(url, auth, volName)
  allLabs <- lapply(treeIDs, function(x) getTree(url, auth, treeID = x)) %>% rbindlist(.)
  if(checkFilename){
    if(!all(labReport$filename %in% imgList$filename)){
      stop("Cannot find input filename of labelReport in this volume. Please check input labelReport is consist with target volume.")
    }
  }
  message("You are going to reconstruct labels in volume:\n", volName)
  if(readline(prompt = "Are you sure to do that? (y/n)") == "y"){
    t1=Sys.time()
    message("Labeling start...")
    failed <- NULL
    imgSeq <- imgList$filename
    pb <- progress_bar$new(format = "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated time remaining: :eta]",
                           total = length(imgSeq))
    for (i in seq_along(imgSeq)) {
      shortcut <- labReport[filename == imgSeq[i]]$label_id
      for (j in seq_along(shortcut)) {
        res <- postALab(url, auth, imgList$imageID[i], shortcut[j])
        if(!is.null(res)){
          failed <- rbind(failed, data.table(imageFailed = imgList[imageID == res$imageFailed]$filename,
                                             labelFailed = allLabs[id == res$labelFailed]$name))
        }
      }
      pb$tick()
    }
    t2=Sys.time()
    message("\nLabeling done. [Consumimg time: ", difftime(t2,t1, units = "min") %>% round(.,2), " min]")
    if(length(failed != 0)){
      message("Result: Some labeling failed, please check the bellowing failed list.")
      return(failed)
    }else{
      message("Result: Labeling all succeed.")
    }
  }else{
    message("Labeling canceled.")
  }
}


#' Post annotations for volume (reconstruct the volume)
#'
#' Reconstruct the volume's annotation from a annotation report (must be csv type).
#' For example, there are 2 volume contain the same image files. "Volume A" have some annotation records and "Volume B" is empty. You can use this function and input the annotation report of "Volume A" to post the same annotation record on "Volume B".\cr
#' Note that: This function post annotations based on the filename. So, the 2 volume must have the same image filename.
#'
#' @param url BIIGLE server URL (e.g. "https://seaimage.oc.ntu.edu.tw").
#' @param auth Authentication string generated by \code{\link{genAuth}}.
#' @param volName The empty volume going to post (reconstruct) annotations.
#' @param treeIDs Label trees  that need to use in this volume (vector with integer).
#' @param annoReport The annotation report table (csv type). It can get by \code{\link{reqNgetRep}}.
#' @param checkFilename (OPTIONAL) Check whether the filename of input annotation report all exist in volume's image (imgList). Default: TRUE
#' @examples
#' \dontrun{
#' postAnnos_re(url = "https://seaimage.oc.ntu.edu.tw",
#'              auth = myAuth,
#'              volName = "odbiigle",
#'              treeIDs = 5,
#'              annoReport = testReport,
#'              checkFilename = TRUE)
#' }
#' @export
postAnnos_re <- function(url, auth, volName, treeIDs, annoReport, checkFilename = TRUE){
  imgList <- getVolImg(url, auth, volName)
  allLabs <- lapply(treeIDs, function(x) getTree(url, auth, treeID = x)) %>% rbindlist(.)
  if(!checkFilename){
    if(!all(annoReport$filename %in% imgList$filename)){
      stop("Cannot find input filename of annoReport in this volume. Please check input annoReport is consist with target volume.")
    }
  }
  message("You are going to reconstruct annotations in volume:\n", volName)
  if(readline(prompt = "Are you sure to do that? (y/n)") == "y"){
    t1=Sys.time()
    message("Annotating start...")
    failed <- NULL
    imgSeq <- imgList$filename
    pb <- progress_bar$new(format = "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated time remaining: :eta]",
                           total = length(imgSeq))
    for (i in seq_along(imgSeq)) {
      tmp <- annoReport[filename == imgSeq[i]]
      if(nrow(tmp) > 0){
        for (j in 1:nrow(tmp)) {
          res <- postAAnno(url, auth, imgList$imageID[i], tmp$shape_id[j], tmp$label_id[j], tmp$points[j])
          if(!is.null(res)){
            failed <- rbind(failed, data.table(imageFailed = imgList[imageID == res$imageFailed]$filename,
                                               labelFailed = allLabs[id == res$labelFailed]$name,
                                               pointFailed = res$point,
                                               shapeFailed = res$shapeID))
          }
        }
      }
      pb$tick()
    }
    t2=Sys.time()
    message("\nAnnotating done. [Consumimg time: ", difftime(t2,t1, units = "min") %>% round(.,2), " min]")
    if(length(failed != 0)){
      message("Result: Some annotating failed, please check the bellowing failed list.")
      return(failed)
    }else{
      message("Result: Annotating all succeed.")
    }
  }else{
    message("Annotating canceled.")
  }
}


#' Delete all labels on images in filename order.
#'
#' Delete all labels on images IN `filename` ORDER! Hence, DO NOT use "Random" to sort files on BIIGLE, otherwise you may misleading yourself which image's label you are going to delete.
#'
#' @param auth Authentication string generated by \code{\link{genAuth}}.
#' @param imgStart (OPTIONAL) The start image's filename. Default: NULL (If \code{imgStart} and \code{imgEnd} are both \code{NULL}, it will delete for ALL labels in the volume).
#' @param imgEnd (OPTIONAL) The end image's filename Default: NULL (If only 1 image to delete, set the same as the `imgStart`; If \code{imgStart} and \code{imgEnd} are both \code{NULL}, it will delete for ALL labels in the volume).
#' @param volName The volume going to delete labels.
#' @param url BIIGLE server URL (e.g. "https://seaimage.oc.ntu.edu.tw").
#' @examples
#' \dontrun{
#' delAllLabs(url = "https://seaimage.oc.ntu.edu.tw",
#'            auth = myAuth,
#'            volName = "odbiigle",
#'            imgStart = "2006_10_07_16_29_30.jpg",
#'            imgEnd = "2006_10_07_16_29_40.jpg")
#' }
#' @export
delAllLabs <- function(url, auth, volName, imgStart = NULL, imgEnd = NULL){
  imgList <- getVolImg(url, auth, volName)
  if(is.null(imgStart) & is.null(imgEnd)){
    targetImgID <- imgList$imageID
    message("You are going to delete labels in volume '", volName, "' for ALL images.")
  }else{
    if(!all(c(imgStart, imgEnd) %in% imgList$filename)){
      stop("Cannot find input image in this volume. Please check the image filename correct.")
    }
    targetImgID <- imgList$imageID[which(imgList$filename == imgStart):which(imgList$filename == imgEnd)]
    message("You are going to delete labels in volume '", volName, "' for images:\n", imgStart, " ~ ", imgEnd)
  }
  if(readline(prompt = "Are you sure to do that? (y/n)") == "y"){
    t1=Sys.time()
    message("Deletion start...")
    pb <- progress_bar$new(format = "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated time remaining: :eta]",
                           total = length(targetImgID))
    failed <- NULL
    for (i in seq_along(targetImgID)) {
      res <- GET(url = paste0(url, "/api/v1/images/", targetImgID[i],"/labels")
                 , add_headers(Accept = "application/json"
                               ,Authorization = auth))
      if(length(content(res)) == 0){
        next
      }else{
        imgLabID <- NULL
        for (j in 1:length(content(res))) {
          imgLabID <- c(imgLabID, content(res)[[j]]$id)
        }
        allLabDel <- sapply(imgLabID, function(x) delALab(url, auth, x)) %>% unlist() %>% all
        if(!allLabDel){
          failed <- c(failed, targetImgID[i])
        }
      }
      pb$tick()
    }
    t2=Sys.time()
    message("\nDeletion done. [Consumimg time: ", difftime(t2,t1, units = "min") %>% round(.,2), " min]")
    if(length(failed != 0)){
      message("Result: Some deletion failed, please check the bellowing failed list (note: it may be because image exist with the label NOT added by you, so you don't have permission to delete it).")
      return(imgList[imageID %in% failed])
    }else{
      message("Result: Deletion all succeed.")
    }
  }else{
    message("Deletion canceled.")
  }
}


#' Delete all annotations on images in filename order.
#'
#' Delete all annotations on images IN `filename` ORDER! Hence, DO NOT use "Random" to sort files on BIIGLE, otherwise you may misleading yourself which image's annotation you are going to delete.
#'
#' @param auth Authentication string generated by \code{\link{genAuth}}.
#' @param url BIIGLE server URL (e.g. "https://seaimage.oc.ntu.edu.tw").
#' @param imgStart (OPTIONAL) The start image's filename. Default: NULL (If \code{imgStart} and \code{imgEnd} are both \code{NULL}, it will delete for ALL annotations in the volume).
#' @param imgEnd (OPTIONAL) The end image's filename Default: NULL (If only 1 image to delete, set the same as the `imgStart`; If \code{imgStart} and \code{imgEnd} are both \code{NULL}, it will delete for ALL annotations in the volume).
#' @param volName The volume going to delete annotations.
#' @examples
#' \dontrun{
#' delAllAnnos(url = "https://seaimage.oc.ntu.edu.tw",
#'             auth = myAuth,
#'             volName = "odbiigle",
#'             imgStart = "2006_10_07_16_29_30.jpg",
#'             imgEnd = "2006_10_07_16_29_40.jpg")
#' }
#' @export
delAllAnnos <- function(url, auth, volName, imgStart = NULL, imgEnd = NULL){
  imgList <- getVolImg(url, auth, volName)
  if(is.null(imgStart) & is.null(imgEnd)){
    targetImgID <- imgList$imageID
    message("You are going to delete annotations in volume '", volName, "' for ALL images.")
  }else{
    if(!all(c(imgStart, imgEnd) %in% imgList$filename)){
      stop("Cannot find input image in this volume. Please check the image filename correct.")
    }
    targetImgID <- imgList$imageID[which(imgList$filename == imgStart):which(imgList$filename == imgEnd)]
    message("You are going to delete annotations in volume '", volName, "' for images:\n", imgStart, " ~ ", imgEnd)
  }
  if(readline(prompt = "Are you sure to do that? (y/n)") == "y"){
    t1=Sys.time()
    message("Deletion start...")
    pb <- progress_bar$new(format = "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated time remaining: :eta]",
                           total = length(targetImgID))
    failed <- NULL
    for (i in seq_along(targetImgID)) {
      res <- GET(url = paste0(url, "/api/v1/images/", targetImgID[i],"/annotations")
                 , add_headers(Accept = "application/json"
                               ,Authorization = auth))
      if(res$status_code != 200){
        stop("Authentication failed.\nPlease check your token is correct and authenticated to access this project.")
      }else{
       annoIDs <- rbindlist(content(res), use.names = TRUE) %>% .$id %>% unique
      }

      if(length(annoIDs) == 0){
        next
      }else{
        allSuc <- all(sapply(annoIDs, function(x) delAAnno(url,auth,x)))
        if(!allSuc){
          failed <- c(failed, targetImgID[i])
        }
      }
      pb$tick()
    }
    t2=Sys.time()
    message("\nDeletion done. [Consumimg time: ", difftime(t2,t1, units = "min") %>% round(.,2), " min]")
    if(length(failed != 0)){
      message("Result: Some deletion failed, please check the bellowing failed list.")
      return(imgList[imageID %in% failed])
    }else{
      message("Result: Deletion all succeed.")
    }
  }else{
    message("Deletion canceled.")
  }
}

